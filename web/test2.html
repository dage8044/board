<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBovU6m43JTTIwwg-KQ8IbXZ0SKjJPxvaw&callback=initMap"></script>
    <title>기상청 날씨 API 연습</title>
    <style>
        table {
            width: 900px;
            height: 300px;
            border-collapse: collapse;
        }
        th, td {
            padding-left: 1px;
            padding-right: 1px;
            text-align: center;
            border-style: solid;
            border-top: 1px solid #dddddd;
            border-bottom: 1px solid #dddddd;
            border-left: 1px solid #dddddd;
            border-right: 1px solid #dddddd;
        }
        .button-container {
            display: block;
            margin-left: 450px;
            margin-top: 20px; 
        }
        table {
            float: left; /* 왼쪽으로 부유(floating) */
        }
        .container {
            position: relative;
        }
        #map{
            position: fixed;
            top: 0;
            right: 0;
            left: 40px;
            width: 500px;
            height: 300px; 
        }
    </style>
</head>
<body>
    <h1>기상청 날씨</h1>
    <h2 id="region"></h2>
    <div class="container"></div>
        <table>
            <thead>
                <tr>
                    <th></th>
                    <th colspan="12" id="today-date"></th>
                    <th colspan="12" id="tomorrow-date"></th>
                </tr>
            </thead>
            <tbody class="result"></tbody>
        </table>
        <div id="map"></div>
    </div>
    <div class="button-container">
        <button onclick="getPreviousWeather()">&lt;</button>
        <button onclick="getNextWeather()">&gt;</button>
    </div>
    <div style="width: 1500px; height: 250px;">
        <canvas id="temperature-chart"></canvas>
    </div>
    <script src="https://code.jquery.com/jquery-3.6.4.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
    <script>
        var now = new Date();
        var year = now.getFullYear();
        var month = (now.getMonth() + 1).toString().padStart(2, '0');
        var day = now.getDate().toString().padStart(2, '0');
        var base_date = year + month + day;
        var base_time = '0500'; // 기본 시간은 05시로 설정
        var cnt = 1; // 기본 cnt 값은 1로 설정
        var dayday = 1;
        var len = 1;
        var lenlen = 0;
        var nx = 61; // 기본 nx 값은 61로 설정
        var ny = 131; // 기본 ny 값은 133로 설정
        var chart;
        // 초기 날짜 설정
        var today = getFormattedDateString(now);
        var tomorrow = getFormattedDateString(new Date(year, now.getMonth(), now.getDate() + 1));
        document.getElementById('region').textContent = '회천3동'
        // 날짜 입력
        document.getElementById('today-date').textContent = today;
        document.getElementById('tomorrow-date').textContent = tomorrow;

        // API 요청 및 데이터 업데이트
        getWeatherData();
        var map;
        var marker;
        var geocoder;

        var RE = 6371.00877; // 지구 반경(km)
        var GRID = 5.0; // 격자 간격(km)
        var SLAT1 = 30.0; // 투영 위도1(degree)
        var SLAT2 = 60.0; // 투영 위도2(degree)
        var OLON = 126.0; // 기준점 경도(degree)
        var OLAT = 38.0; // 기준점 위도(degree)
        var XO = 43; // 기준점 X좌표(GRID)
        var YO = 136; // 기1준점 Y좌표(GRID)
        //
        // LCC DFS 좌표변환 ( code : "toXY"(위경도->좌표, v1:위도, v2:경도), "toLL"(좌표->위경도,v1:x, v2:y) )
        //


        function dfs_xy_conv(code, v1, v2) {
            var DEGRAD = Math.PI / 180.0;
            var RADDEG = 180.0 / Math.PI;

            var re = RE / GRID;
            var slat1 = SLAT1 * DEGRAD;
            var slat2 = SLAT2 * DEGRAD;
            var olon = OLON * DEGRAD;
            var olat = OLAT * DEGRAD;

            var sn = Math.tan(Math.PI * 0.25 + slat2 * 0.5) / Math.tan(Math.PI * 0.25 + slat1 * 0.5);
            sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);
            var sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);
            sf = Math.pow(sf, sn) * Math.cos(slat1) / sn;
            var ro = Math.tan(Math.PI * 0.25 + olat * 0.5);
            ro = re * sf / Math.pow(ro, sn);
            var rs = {};
            if (code == "toXY") {
                rs['lat'] = v1;
                rs['lng'] = v2;
                var ra = Math.tan(Math.PI * 0.25 + (v1) * DEGRAD * 0.5);
                ra = re * sf / Math.pow(ra, sn);
                var theta = v2 * DEGRAD - olon;
                if (theta > Math.PI) theta -= 2.0 * Math.PI;
                if (theta < -Math.PI) theta += 2.0 * Math.PI;
                theta *= sn;
                rs['x'] = Math.floor(ra * Math.sin(theta) + XO + 0.5);
                rs['y'] = Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);
            }
            else {
                rs['x'] = v1;
                rs['y'] = v2;
                var xn = v1 - XO;
                var yn = ro - v2 + YO;
                ra = Math.sqrt(xn * xn + yn * yn);
                if (sn < 0.0) - ra;
                var alat = Math.pow((re * sf / ra), (1.0 / sn));
                alat = 2.0 * Math.atan(alat) - Math.PI * 0.5;

                if (Math.abs(xn) <= 0.0) {
                    theta = 0.0;
                }
                else {
                    if (Math.abs(yn) <= 0.0) {
                        theta = Math.PI * 0.5;
                        if (xn < 0.0) - theta;
                    }
                    else theta = Math.atan2(xn, yn);
                }
                var alon = theta / sn + olon;
                rs['lat'] = alat * RADDEG;
                rs['lng'] = alon * RADDEG;
            }
            return rs;
        }

        function initMap() {
            // 맵 초기화
            map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 37.5, lng: 127.0 },
            zoom: 10
            });

            // 클릭 이벤트 리스너 추가
            map.addListener("click", function(event) {
            placeMarker(event.latLng); // 클릭한 위치에 마커를 표시하는 함수 호출
            });

            // 지오코딩 서비스 초기화
            geocoder = new google.maps.Geocoder();
        }

        function placeMarker(location) {
            // 기존 마커 제거
            if (marker) {
            marker.setMap(null);
            }

            // 클릭한 위치에 새로운 마커 생성
            marker = new google.maps.Marker({
            position: location,
            map: map
            });

            // 클릭한 위치의 좌표 출력
            var lat = location.lat();
            var lng = location.lng();

            // 좌표를 주소로 변환
            geocodeLatLng(lat, lng);
        }

        function geocodeLatLng(lat, lng) {
            var latLng = new google.maps.LatLng(lat, lng);

            var geocoder = new google.maps.Geocoder();
            var geocoderRequest = {
            location: latLng
            };

            geocoder.geocode(geocoderRequest, function(results, status) {
            if (status === "OK") {
                if (results[0]) {
                var address = results[0].formatted_address;
                document.getElementById('region').textContent = address
                console.log("클릭한 위치의 주소: " + address);
                var ping = dfs_xy_conv("toXY", lat, lng)
                nx = ping.x;
                ny = ping.y;
                getWeatherData();
                } else {
                console.log("주소 정보를 찾을 수 없습니다.");
                }
            } else {
                console.log("지오코딩 요청에 실패했습니다. 상태: " + status);
            }
            });
        }
        // 이전 날짜 가져오기
        function getPreviousWeather() {
            if (dayday === 0){
                    alert("하루 전까지의 정보만 제공됩니다.")
                }
            else{
                var currentDate = new Date(year, month - 1, day);
                currentDate.setDate(currentDate.getDate() - 1);
                year = currentDate.getFullYear();
                month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                day = currentDate.getDate().toString().padStart(2, '0');
                var previousBaseDate = year + month + day;
                
                cnt = 1
                dayday -= 1
                if (dayday > 1){
                    var previousDateString = getFormattedDateString(currentDate);
                    document.getElementById('today-date').textContent = previousDateString;
                    today = previousDateString;

                    tomorrow = getFormattedDateString(new Date(year, currentDate.getMonth(), currentDate.getDate() + 1));
                    document.getElementById('tomorrow-date').textContent = tomorrow;
                    getWeatherData();
                }else{ 
                    // 날짜 업데이트
                    base_date = previousBaseDate;
                    var previousDateString = getFormattedDateString(currentDate);
                    document.getElementById('today-date').textContent = previousDateString;
                    today = previousDateString;

                    tomorrow = getFormattedDateString(new Date(year, currentDate.getMonth(), currentDate.getDate() + 1));
                    document.getElementById('tomorrow-date').textContent = tomorrow;
                    getWeatherData();
                }
            }    
        }

        // 다음 날짜 가져오기
        function getNextWeather() {
            if (dayday === 2){
                    alert("하루 후까지의 정보가 제공됩니다.")
                }
            else{
                var currentDate = new Date(year, month - 1, day);
                currentDate.setDate(currentDate.getDate() + 1);
                year = currentDate.getFullYear();
                month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                day = currentDate.getDate().toString().padStart(2, '0');
                var nextBaseDate = year + month + day;
                dayday += 1
                if (dayday > 1){
                    cnt = dayday
                    var nextDateString = getFormattedDateString(currentDate);
                    document.getElementById('today-date').textContent = nextDateString;
                    today = nextDateString;

                    tomorrow = getFormattedDateString(new Date(year, currentDate.getMonth(), currentDate.getDate() + 1));
                    document.getElementById('tomorrow-date').textContent = tomorrow;

                    getWeatherData();
                    }               
                else{
                    cnt = 1
                    // 날짜 업데이트
                    var nextDateString = getFormattedDateString(currentDate);
                    document.getElementById('today-date').textContent = nextDateString;
                    today = nextDateString;

                    tomorrow = getFormattedDateString(new Date(year, currentDate.getMonth(), currentDate.getDate() + 1));
                    document.getElementById('tomorrow-date').textContent = tomorrow;

                    // base_date 업데이트
                    base_date = nextBaseDate;

                    // 날씨 데이터 요청
                    getWeatherData();
                }
            }        
        }
        // 온도 변화 차트 생성
        function createChart(realtimeList, tmpdata) {
            var ctx = document.getElementById('temperature-chart').getContext('2d');
            var options = {
            maintainAspectRatio: false, 
            };

            // 차트 생성
            chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: realtimeList,
                datasets:[
                    {
                        label: '온도 변화',
                        fill: false,
                        data: tmpdata,
                        borderColor: [
                            //경계선 색상
                            'rgba(0, 0, 0, 1)'
                        ],
                        borderWidth: 1
                    }
                ]
            },
            options: options
            });
        }
        // 표시 날짜 형식 변경
        function getFormattedDateString(date) {
            var month = (date.getMonth() + 1).toString().padStart(2, '0');
            var day = date.getDate().toString().padStart(2, '0');
            var formattedDateString = month + '/' + day;

            return formattedDateString;
        }

        // 날씨 데이터 요청
        function getWeatherData() {
            $.ajax({
                url: 'https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst',
                type: 'GET',
                dataType: 'json',
                data: {
                    serviceKey: decodeURIComponent('wGvp1N3oiF2JaBTqPZZt2X8t6%2FlE8LjMzSKc0I4UpD98tKCnEEzYEajAw5HnBDrzO1y3evtljDkcgT5BG2dNjg%3D%3D'),
                    pageNo: 1,
                    numOfRows: 1000,
                    dataType: 'JSON',
                    base_date: base_date,
                    base_time: base_time,
                    nx: nx,
                    ny: ny
                },
                success: function(data) {
                    console.log(data);
                    updateWeatherData(data);
                },
                error: function(error) {
                    console.error('API 요청 에러:', error);
                }
            });
        }
        // 하늘 상태 분석함수
        function getWeatherStatus(pty, sky) {
            let imagePath = '';

            if (pty === "0") {
                if (sky === "1") {
                    imagePath = 'sunny.png'; // 맑음 이미지 경로
                } else if (sky === "3") {
                    imagePath = 'cloudy.png'; // 구름많음 이미지 경로
                } else if (sky === "4") {
                    imagePath = 'overcast.png'; // 흐림 이미지 경로
                }
            } else {
                if (pty === "1" || pty === "4") {
                    imagePath = 'rain.png'; // 비 이미지 경로
                } else if (pty === "2") {
                    imagePath = 'rain_snow.png'; // 비/눈 이미지 경로
                } else if (pty === "3") {
                    imagePath = 'snow.png'; // 눈 이미지 경로
                }
            }

            return '<img src="' + imagePath + '" alt="">';
        }

        // 데이터 모아서 분석
        function updateWeatherData(data) {
            let items = data.response.body.items.item;
            let categoryData = {
                POP: [], // 강수확률
                REH: [], // 습도
                TMP: [], // 기온
                VEC: [], // 풍향
                WSD: [], // 풍속
            };
            let skyData = {
                PTY: [], // 강수형태
                SKY: [], // 하늘상태
            };
            let category2 = ["강수확률", "습도", "온도", "풍향", "풍속"];
            let timeList = []; // 시간 리스트
            var tmpdata = []; // 온도 리스트
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                let category = item.category;
                let value = item.fcstValue;
                let time = item.fcstTime;

                // 지정된 카테고리만 데이터를 저장
                if (categoryData.hasOwnProperty(category)) {
                    categoryData[category].push(value);
                }
                // 하늘 값들 저장
                if (skyData.hasOwnProperty(category)) {
                    skyData[category].push(value);
                }
                
                timeList.push(time);
                
            }
            let htmlRows = '';
            let categories = Object.keys(categoryData); // 사용하는 카테고리 리스트
            let sky = Object.keys(skyData);

            htmlRows += '<tr><th>시간</th>'; // 첫 번째 열에 시간 칸 추가

            // 시작점 찾기
            let time = now.getHours()+'00';
            let start = 0;
            let first = 24 - parseInt(now.getHours(), 10);
            let second = 24 - first;
            let targettoday = document.getElementById('today-date');
            targettoday.colSpan = first
            let targettomorrow = document.getElementById('tomorrow-date');
            targettomorrow.colSpan = second;
            for (let i = 0; i < timeList.length; i++) {
                if (timeList[i] === time){
                    break
                }else{
                    start += 1
                }
            }
            let realtimeList = []
            // 시간 값을 열로 추가
            for (let i = start; i < timeList.length; i++) {
                if (!realtimeList.includes(timeList[i])){
                    realtimeList.push(timeList[i])
                    let time = timeList[i].substr(0,2);
                    htmlRows += '<th>' + time + '</th>';
                }
                
            }

            htmlRows += '</tr>';

            htmlRows += '<tr><th>날씨</th>'; // 두 번째 열에 날씨 칸 추가

            // 하늘 값을 열로 추가
            start = Math.floor(start/12);
            console.log(start)
            console.log(skyData.PTY.length)
            for (let i = (cnt - 1)*24 + start ; i < start + cnt * 24; i++) {
                let pty = skyData.PTY[i];
                let sky = skyData.SKY[i];
                console.log(i)
                let weatherStatus = getWeatherStatus(pty, sky);
                htmlRows += '<th>' + weatherStatus + '</th>';
            }

            for (let i = 0; i < categories.length; i++) {
                let category = categories[i];
                let values = categoryData[category]; // 해당 카테고리의 값 리스트
                htmlRows += '<tr>' +
                    '<th>' + category2[i] + '</th>'; // 카테고리명을 표시하는 열

                // 값 리스트를 HTML에 추가
                for (let j = 0; j < realtimeList.length; j++) {
                    let time = realtimeList[j];
                    let value = ''; // 기본값은 빈 문자열

                    // 해당 시간의 값을 찾아서 value에 할당
                    for (let k = (cnt - 1) * 24+start*12; k < items.length; k++) {
                        let item = items[k];
                        if (item.category === category && item.fcstTime === time) {
                            if (item.category === 'TMP'){
                                tmpdata.push(item.fcstValue)
                            }
                            value = item.fcstValue;
                            break;
                        }
                    }

                    htmlRows += '<td>' + value + '</td>';
                }
                htmlRows += '</tr>';
            }

            $('.result').html(htmlRows); // HTML에 결과값 적용
            if (chart){
                chart.destroy()
            }
            createChart(realtimeList, tmpdata);
        }
        initMap();
    </script>
    
</body>
</html>
